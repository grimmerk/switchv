import { exec } from 'child_process';
import {
  app,
  BrowserWindow,
  dialog,
  globalShortcut,
  ipcMain,
  screen,
} from 'electron';
import settings from 'electron-settings';
import { existsSync, readdirSync } from 'fs';
import { DBManager } from './DBManager';
import { isMAS, TrayGenerator } from './TrayGenerator';
import { bootstrap } from './server/server';
import { AIAssistantUIMode, isDebug } from './utility';

const clipboard = require('electron').clipboard;
const { execFile } = require('child_process');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
// AI Assistant window entry point
declare const AI_ASSISTANT_WINDOW_WEBPACK_ENTRY: string;
// Settings window entry point
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

let tray: TrayGenerator = null;
let mainWindow: BrowserWindow = null;
let aiAssistantWindow: BrowserWindow = null; // Track the AI Assistant window
let settingsWindow: BrowserWindow = null; // Track the settings window
let serverProcess: any;

const WIN_WIDTH = 800;
const WIN_HEIGHT = 600;

const getWindowPosition = () => {
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;

  const x = Math.round(width / 2 - WIN_WIDTH / 2);
  const y = Math.round(height / 2 - WIN_HEIGHT / 2);

  return { x, y };
};

// ref: https://blog.logrocket.com/building-a-menu-bar-application-with-electron-and-react/
// NOTE: setVisibleOnAllWorkspaces is needed ?
const showWindow = () => {
  const position = getWindowPosition();
  mainWindow.setPosition(position.x, position.y, false);
  mainWindow.show();
  // mainWindow.setVisibleOnAllWorkspaces(true);
  mainWindow.focus();
  // mainWindow.setVisibleOnAllWorkspaces(false);
};

const showAIAssistantWindow = () => {
  const position = getWindowPosition();
  aiAssistantWindow.setPosition(position.x, position.y, false);
  aiAssistantWindow.show();
  // mainWindow.setVisibleOnAllWorkspaces(true);
  aiAssistantWindow.focus();
  // mainWindow.setVisibleOnAllWorkspaces(false);
};

// Handle chat messages from the AI Assistant window
ipcMain.on('send-chat-message', (event, message, messageHistory) => {
  // Get the window that sent this message
  const sender = BrowserWindow.fromWebContents(event.sender);
  if (sender && !sender.isDestroyed()) {
    // Forward the message to AnthropicService
    anthropicService.handleChatMessage(message, sender, messageHistory);
  }
});

// Handle UI mode changes to track the current mode
ipcMain.on('ui-mode-changed', (event, mode) => {
  lastUIMode = mode;
});

// Handle insight completion status
ipcMain.on('insight-completed', (event, completed) => {
  lastExplanationCompleted = completed; // Keep the same variable name for backward compatibility
});

// Legacy event for backward compatibility
ipcMain.on('explanation-completed', (event, completed) => {
  lastExplanationCompleted = completed;
});

const hideWindow = () => {
  mainWindow.hide();
};

const onBlur = (event: any) => {
  hideWindow();
};

const onFocus = (event: any) => {
  mainWindow.webContents.send('window-focus');
};

const createAIAssistantWindow = (): BrowserWindow => {
  // If window already exists, just return it - visibility is handled by the caller
  if (aiAssistantWindow && !aiAssistantWindow.isDestroyed()) {
    if (aiAssistantWindow.isMinimized()) {
      aiAssistantWindow.restore();
    }
    aiAssistantWindow.focus();
    return aiAssistantWindow;
  }

  // Calculate position to create a semi-transparent floating window
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;

  // Create window with 800x600 size positioned at the center of the screen
  // Performance optimizations added
  aiAssistantWindow = new BrowserWindow({
    width: 800,
    height: 600,
    x: Math.round(width / 2 - 400),
    y: Math.round(height / 2 - 300),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      devTools: false, // Always enable DevTools for debugging
      nodeIntegration: false,
      contextIsolation: true,
      // Performance optimizations
      backgroundThrottling: false, // Prevents throttling when window is in background
      spellcheck: false, // Disable spellcheck for better performance
      enableBlinkFeatures: 'CompositorThreadedScrollbarScrolling', // Use threaded scrolling
    },
    show: true, // Show immediately for better perceived performance
    frame: true,
    fullscreenable: false,
    resizable: true,
    // Solid background
    backgroundColor: '#2d2d2d', // Pre-paint with background color
    opacity: 1.0,
    // Always on top to ensure visibility
    alwaysOnTop: true,
    // Performance optimization
    paintWhenInitiallyHidden: true, // Paint even when initially hidden
  });

  // Load the AI Assistant renderer
  aiAssistantWindow.loadURL(AI_ASSISTANT_WINDOW_WEBPACK_ENTRY);

  // Open DevTools in detached mode to help debug
  if (isDebug) {
    aiAssistantWindow.webContents.openDevTools({ mode: 'detach' });
  }

  // Handle window closed event
  aiAssistantWindow.on('closed', () => {
    aiAssistantWindow = null;
  });

  /** TODO: add window.on('move', () => { */

  return aiAssistantWindow;
};

// Legacy function for backward compatibility - will be removed after migration
const createCodeaiAssistantWindow = (): BrowserWindow => {
  return createAIAssistantWindow();
};

const createSettingsWindow = (
  settingsType: string = 'explainer',
): BrowserWindow => {
  // If window already exists, just return it - visibility is handled by the caller
  if (settingsWindow && !settingsWindow.isDestroyed()) {
    if (settingsWindow.isMinimized()) {
      settingsWindow.restore();
    }
    settingsWindow.focus();

    // Send message to switch to the specified settings type
    if (settingsType === 'explainer') {
      settingsWindow.webContents.send('open-explainer-settings');
    } else if (settingsType === 'apiKey') {
      settingsWindow.webContents.send('open-api-key-settings');
    } else if (settingsType === 'leftClick') {
      settingsWindow.webContents.send('open-left-click-settings');
    }

    return settingsWindow;
  }

  // Calculate position for settings window
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;

  // Create settings window - increased height to ensure save message is visible
  settingsWindow = new BrowserWindow({
    width: 800,
    height: 650, // Increased from 600 to ensure save message is fully visible
    x: Math.round(width / 2 - 400),
    y: Math.round(height / 2 - 325), // Adjusted y position to center the taller window
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      devTools: false,
      nodeIntegration: false,
      contextIsolation: true,
    },
    show: true,
    frame: true,
    fullscreenable: false,
    resizable: true,
    backgroundColor: '#1a1a1a',
  });

  // Load the settings renderer with the appropriate settings type as a query parameter
  settingsWindow.loadURL(
    `${SETTINGS_WINDOW_WEBPACK_ENTRY}?type=${settingsType}`,
  );

  // Open DevTools in detached mode to help debug
  if (isDebug) {
    settingsWindow.webContents.openDevTools({ mode: 'detach' });
  }

  // Handle window closed event
  settingsWindow.on('closed', () => {
    settingsWindow = null;
  });

  return settingsWindow;
};

const createWindow = (): BrowserWindow => {
  // Create the browser window.
  const window = new BrowserWindow({
    // maximizable: false,
    // minimizable: false, // ux not good
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      devTools: false, //isDebug,
    },

    // hide window by default
    show: false,
    frame: false,
    fullscreenable: false,
    resizable: false,
  });

  // and load the index.html of the app.
  window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // if (true){ //isDebug){//!app.isPackaged) {
  // window.webContents.openDevTools();
  // }

  if (tray) {
    // TODO: change to use some Tray method & not set tray here
    tray.mainWindow = window;
  }

  window.on('blur', onBlur);
  window.on('focus', onFocus);

  // mainWindow.on('close', function (event) {
  //   console.log("mainWindow close");
  //   // if below is setup, app.window-all-closed will not be fired
  //   // if(!application.isQuiting){
  //   // event.preventDefault();
  //   // mainWindow.hide();
  //   // // }
  //   // return false;
  // });

  window.on('move', () => {
    const bounds = mainWindow.getBounds();
    const currentDisplay = screen.getDisplayNearestPoint({
      x: bounds.x,
      y: bounds.y,
    });

    showWindow();
  });

  return window;
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  if (isDebug) {
    console.log('on ready');
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (isDebug) {
    console.log('window-all-closed');
  }
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

/** not triggered yet */
app.on('activate', () => {
  if (isDebug) {
    console.log('activate');
  }
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    mainWindow = createWindow();
  }
});

/** https://www.electronjs.org/docs/latest/tutorial/ipc */
ipcMain.on('invoke-vscode', (event, path, option) => {
  // if (isDebug) {
  //   console.log('invoke', { /*event,*/ path });
  //   tray.tray.setTitle(`CodeV(${path ? path[path.length - 1] : 'n'})`);
  // }

  if (!existsSync(path)) {
    if (isDebug) {
      console.log('file not exist');
    }
    // send message to Electron, not really use now, just in case
    mainWindow.webContents.send('xwin-not-found');

    dialog.showMessageBox(mainWindow, {
      message: 'Path is not a folder, neither workspace',
      buttons: ['OK'],
      defaultId: 0, // bound to buttons array
      cancelId: 1, // bound to buttons array
    });

    return;
  }

  /** TODO: use Node.js path.join() instead of manual concat */
  // FIXME: win/linux has difference path
  // ref:
  // 1. https://stackoverflow.com/questions/44405523/spawn-child-node-process-from-electron
  // 2. https://stackoverflow.com/questions/62885809/nodejs-child-process-npm-command-not-found
  // 3. https://github.com/electron/fiddle/issues/365#issuecomment-616630874
  // const fullCmd = `code ${command}`
  // const child = spawn('open', ['-b', 'com.microsoft.VSCode', '--args', argv], options);
  // https://github.com/microsoft/vscode/issues/102975#issuecomment-661647219
  // const fullCmd = `open -b com.microsoft.VSCode --args -r ${path}`

  let fullCmd = '';
  const newPath = path.replace(/ /g, '\\ ');
  if (option) {
    // reuse
    // https://stackoverflow.com/a/47473271/7354486
    // https://code.visualstudio.com/docs/editor/command-line#_opening-vs-code-with-urls
    fullCmd = `open vscode://file/${newPath}`;
  } else {
    // NOTE: VSCode insider needs to use "com.microsoft.VSCodeInsiders" instead
    fullCmd = `open -b com.microsoft.VSCode ${newPath}`;
  }

  if (isDebug) {
    console.log({ fullCmd });
  }
  exec(fullCmd, (error, stdout, stderr) => {
    if (isDebug) {
      console.log(stdout);
    }
  });

  hideWindow();
});

ipcMain.on('pop-alert', (event, alert: string) => {
  dialog.showMessageBox(mainWindow, {
    message: alert,
    buttons: ['OK'],
    defaultId: 0, // bound to buttons array
    cancelId: 1, // bound to buttons array
  });
});

ipcMain.on('search-working-folder', (event, path: string) => {
  if (!path) {
    return;
  }

  console.time('readdir');

  // 0.2ms ~ 100 item
  // 0.27ms ~ 2item
  // 0.4ms for git folder, ~200
  /** TODO: use async way to improve performance */
  const directoriesInDIrectory = readdirSync(path, {
    withFileTypes: true,
  });

  /** readdir-all subfolder: 96.554ms */
  const returnPathlist = [];
  // const subListCount = 0; // 3785
  for (const item of directoriesInDIrectory) {
    if (item.name.startsWith('.')) {
      continue;
    }

    const itemPath = path + '/' + item.name;
    if (!item.isDirectory()) {
      if (item.name.endsWith('.code-workspace')) {
        returnPathlist.push(itemPath);
      }
      continue;
    }
    returnPathlist.push(itemPath);

    // TODO: this is macOs path style. use Node.js path.join()
    const targetSpacePath = itemPath + '/' + item.name + '.code-workspace';
    if (existsSync(targetSpacePath)) {
      returnPathlist.push(targetSpacePath);
      // if (targetSpacePath.endsWith('.code-workspace')) {
      //   console.log('targetSpacePath,', targetSpacePath);
      // }
    }
  }

  console.timeEnd('readdir');
  console.log({ returnPathlist: returnPathlist.length });

  mainWindow.webContents.send('working-folder-iterated', returnPathlist);
});

ipcMain.on('hide-app', (event) => {
  hideWindow();
});

ipcMain.on('close-app-click', async (event) => {
  app.quit();
});

// Settings window handlers
ipcMain.on('open-settings', (event, settingsType = 'explainer') => {
  createSettingsWindow(settingsType);
});

// Create Settings windows from tray menu
ipcMain.on('open-explainer-settings', () => {
  createSettingsWindow('explainer');
});

ipcMain.on('open-api-key-settings', () => {
  createSettingsWindow('apiKey');
});

ipcMain.on('open-left-click-settings', () => {
  createSettingsWindow('leftClick');
});

// Import our Anthropic service
import anthropicService from './AnthropicService';

// Track user settings
let userSettings = {
  leftClickBehavior: 'main_window', // Default behavior
};

// Track the last explained code to detect changes
let lastExplainedCode = '';
// Track the last used UI mode to restore it when reopening
let lastUIMode = AIAssistantUIMode.SMART_CHAT;
// Track whether an explanation was completed for the current code
let lastExplanationCompleted = false;

// Handle the request to open AI Assistant window
ipcMain.on('open-ai-assistant', (event, code) => {
  // Check if code is the same as previously analyzed
  const codeChanged = code !== lastExplainedCode;
  lastExplainedCode = code;

  aiAssistantWindow = createAIAssistantWindow();

  // Send the code to the window once it's loaded
  aiAssistantWindow.webContents.once('did-finish-load', () => {
    aiAssistantWindow.webContents.send('code-to-analyze', code);

    // Start analyzing code using the Anthropic service
    anthropicService.explainCode(code, aiAssistantWindow);
  });
});

// Legacy handler for backward compatibility
ipcMain.on('open-code-explainer', (event, code) => {
  // Forward to the new handler
  ipcMain.emit('open-ai-assistant', event, code);
});

ipcMain.on('open-folder-selector', async (event) => {
  const result = await dialog.showOpenDialog({
    properties: ['openDirectory'],
    securityScopedBookmarks: true,
    // properties: ['openFile', 'multiSelections'],
  });
  /** https://gist.github.com/ngehlert/74d5a26990811eed59c635e49134d669 */
  const { canceled, filePaths, bookmarks } = result;
  if (canceled || filePaths.length === 0) {
    return;
  }
  if (bookmarks && bookmarks.length) {
    // store the bookmark key
    if (isMAS()) {
      await settings.set('security-scoped-bookmark', bookmarks[0]);
    }
  }

  const folderPath = filePaths[0];

  mainWindow.webContents.send('folder-selected', folderPath);
});

// Load settings from database with retry mechanism
const loadUserSettings = async () => {
  // Number of retries and delay between retries
  const maxRetries = 3;
  const retryDelay = 1000; // ms

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Add timeout to the fetch request to avoid long waits
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3000);

      const response = await fetch(
        'http://localhost:55688/explainer-settings',
        {
          signal: controller.signal,
        },
      );

      clearTimeout(timeoutId);

      if (response.ok) {
        const settings = await response.json();
        if (settings) {
          userSettings.leftClickBehavior =
            settings.leftClickBehavior || 'main_window';
        }
        return; // Success, exit the function
      }
    } catch (error) {
      // Only log on final attempt
      if (attempt === maxRetries - 1) {
        if (isDebug) {
          console.error('Failed to load user settings after retries:', error);
        }
      } else {
        // Wait before next retry
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
      }
    }
  }

  // If we reached here, all attempts failed
  if (isDebug) {
    console.log('Using default settings after failed load attempts');
  }
};

// Handle Tray icon left-click based on user settings
const trayToggleEvtHandler = async () => {
  if (isDebug) {
    console.log('tray toggle callback');
  }

  // Make sure settings are loaded
  await loadUserSettings();

  // Handle different click behaviors
  if (userSettings.leftClickBehavior === 'code_explainer') {
    // Open Code Explainer with clipboard content
    const selectedCode = clipboard.readText().trim();

    if (selectedCode && selectedCode.length > 0) {
      // Create or focus AI Assistant window
      const aiAssistantWin = createAIAssistantWindow();

      // Make sure the window is visible
      showAIAssistantWindow();

      // Handle loading state properly
      const processCode = () => {
        // Set UI mode to INSIGHT_CHAT
        aiAssistantWin.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.INSIGHT_CHAT,
          {
            code: selectedCode,
          },
        );

        // Send the code and start analysis
        aiAssistantWin.webContents.send('code-to-analyze', selectedCode);
        anthropicService.explainCode(selectedCode, aiAssistantWin);
      };

      // If window is still loading, wait for it to load
      if (aiAssistantWin.webContents.isLoadingMainFrame()) {
        aiAssistantWin.webContents.once('did-finish-load', processCode);
      } else {
        // Window already loaded, process immediately
        processCode();
      }
    } else {
      // No code in clipboard, open Smart Chat instead (better UX than opening main window)
      // Create or focus AI Assistant window
      const aiAssistantWin = createAIAssistantWindow();

      // Show window first for better perceived performance
      showAIAssistantWindow();

      // Set UI mode to SMART_CHAT
      if (aiAssistantWin.webContents.isLoadingMainFrame()) {
        aiAssistantWin.webContents.once('did-finish-load', () => {
          aiAssistantWin.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.SMART_CHAT,
          );
        });
      } else {
        aiAssistantWin.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.SMART_CHAT,
        );
      }
    }
  } else if (userSettings.leftClickBehavior === 'pure_chat') {
    // Open Smart Chat interface

    // Check if AI Assistant window already exists
    if (aiAssistantWindow && !aiAssistantWindow.isDestroyed()) {
      // If window is visible, toggle visibility (hide it)
      if (aiAssistantWindow.isVisible()) {
        aiAssistantWindow.hide();
        return;
      }

      // Show the existing window
      aiAssistantWindow.show();

      // Set UI mode to SMART_CHAT
      if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
        aiAssistantWindow.webContents.once('did-finish-load', () => {
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.SMART_CHAT,
          );
        });
      } else {
        aiAssistantWindow.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.SMART_CHAT,
        );
      }
    } else {
      // Create a new window
      aiAssistantWindow = createAIAssistantWindow();

      // Set UI mode to SMART_CHAT
      if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
        aiAssistantWindow.webContents.once('did-finish-load', () => {
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.SMART_CHAT,
          );
        });
      } else {
        aiAssistantWindow.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.SMART_CHAT,
        );
      }
    }
  } else {
    // Default behavior - toggle main window
    if (BrowserWindow.getAllWindows().length === 0) {
      if (isDebug) {
        console.log('no window, create one');
      }
      mainWindow = createWindow();
      showWindow();
    } else if (mainWindow && mainWindow.isVisible()) {
      if (isDebug) {
        console.log('is visible, to hide');
      }
      hideWindow();
    } else if (mainWindow) {
      if (isDebug) {
        console.log('is not visible, to show');
      }
      showWindow();
    }
  }
};

/**
 * what is the difference between whenReady & .on('ready)???
 */
(async () => {
  await app.whenReady();

  mainWindow = createWindow();
  if (isDebug) {
    console.log('when ready');
  }

  // Pre-initialize aiAssistantWindow for faster first open
  // This is done after mainWindow is created, but before showing it
  // so that initial startup isn't slowed down
  setTimeout(() => {
    // Create explainer window but keep it hidden
    aiAssistantWindow = createCodeaiAssistantWindow();
    aiAssistantWindow.hide(); // Ensure it's hidden

    // Preload PURE_CHAT mode for faster response
    if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
      aiAssistantWindow.webContents.once('did-finish-load', () => {
        aiAssistantWindow.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.SMART_CHAT,
        );
      });
    } else {
      aiAssistantWindow.webContents.send(
        'set-ui-mode',
        AIAssistantUIMode.SMART_CHAT,
      );
    }
  }, 1000); // Delay by 1 second to not interfere with main window initialization

  // Add window closed event handler to explainer window to recreate it when closed
  // This ensures the next opening will still be fast
  const setupaiAssistantWindowRebuild = () => {
    if (aiAssistantWindow && !aiAssistantWindow.isDestroyed()) {
      // Remove any previous listeners to avoid duplicates
      aiAssistantWindow.removeAllListeners('closed');

      // Add new closed listener
      aiAssistantWindow.on('closed', () => {
        // Schedule recreation after a short delay
        setTimeout(() => {
          if (!aiAssistantWindow || aiAssistantWindow.isDestroyed()) {
            aiAssistantWindow = createCodeaiAssistantWindow();
            aiAssistantWindow.hide();
            setupaiAssistantWindowRebuild(); // Setup the listener again for the new window

            // Set PURE_CHAT mode as default for the recreated window
            if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
              aiAssistantWindow.webContents.once('did-finish-load', () => {
                aiAssistantWindow.webContents.send(
                  'set-ui-mode',
                  AIAssistantUIMode.SMART_CHAT,
                );
              });
            } else {
              aiAssistantWindow.webContents.send(
                'set-ui-mode',
                AIAssistantUIMode.SMART_CHAT,
              );
            }
          }
        }, 500);
      });
    }
  };

  // Call this after the initial window is created
  setTimeout(setupaiAssistantWindowRebuild, 2000);

  DBManager.initPath();
  // console.log({
  //   node: process?.env?.NODE_ENV,
  //   DEBUG_PROD: process.env.DEBUG_PROD,
  //   isUnPackaged: isUnPackaged,
  // });
  const needVer = await DBManager.checkNeedMigration();
  if (needVer) {
    await DBManager.doMigrationToVersion(needVer);
  }
  if (isDebug) {
    console.log('check db done. USE DBPATH:', DBManager.databaseFilePath);
  }

  if (isMAS()) {
    const securityBookmark = (await settings.get(
      'security-scoped-bookmark',
    )) as string;
    if (securityBookmark) {
      app.startAccessingSecurityScopedResource(securityBookmark);
    }
  }
  process.env.DATABASE_URL = `file:${DBManager.databaseFilePath}`;
  process.env.PRISMA_QUERY_ENGINE_LIBRARY = DBManager.queryExePath;
  await bootstrap();

  // Load user settings
  await loadUserSettings();

  let title = '';
  if (!isDebug) {
    title = ``;
  } else {
    // title = `CodeV(cmd+ctrl+r/e)`;
    title = `CodeV`;
    if (DBManager.needUpdate) {
      title = `${title}${'u.'}`;
    }
  }

  tray = new TrayGenerator(mainWindow, title, trayToggleEvtHandler);

  // https://www.electronjs.org/docs/latest/tutorial/keyboard-shortcuts#global-shortcuts
  // Register Cmd+Ctrl+R shortcut to always show the main window, regardless of left-click setting
  globalShortcut.register('Command+Control+R', () => {
    if (isDebug) {
      console.log('Command+Control+R triggered - always shows main window');
    }

    if (BrowserWindow.getAllWindows().length === 0) {
      if (isDebug) {
        console.log('No window, creating main window');
      }
      mainWindow = createWindow();
      showWindow();
    } else if (mainWindow && mainWindow.isVisible()) {
      if (isDebug) {
        console.log('Main window visible, hiding it');
      }
      hideWindow();
    } else if (mainWindow) {
      if (isDebug) {
        console.log('Main window exists but hidden, showing it');
      }
      showWindow();
    }
  });

  // Register shortcut for Pure Chat Mode (Ctrl+Cmd+C)
  globalShortcut.register('Command+Control+C', () => {
    // Check if explainer window already exists
    if (aiAssistantWindow && !aiAssistantWindow.isDestroyed()) {
      // If window is visible, check its current mode
      if (aiAssistantWindow.isVisible()) {
        // For now, just hide the window if it's visible (simplified toggle behavior)
        aiAssistantWindow.hide();
        return;
      } else {
        // Performance optimization: Show window immediately before setting mode
        // This improves perceived performance as the window appears faster
        aiAssistantWindow.show();

        // Use setTimeout with 0ms to ensure show() completes first
        setTimeout(() => {
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.SMART_CHAT,
          );
        }, 0);
        return;
      }
    }

    // If we reach here, we need to create a new window
    // Set show:true in createCodeaiAssistantWindow to show window immediately
    aiAssistantWindow = createCodeaiAssistantWindow();

    // Set position immediately to ensure window appears in the right place
    const position = getWindowPosition();
    aiAssistantWindow.setPosition(position.x, position.y, false);

    // Set UI mode after a minimal delay to ensure window is visible first
    if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
      aiAssistantWindow.webContents.once('did-finish-load', () => {
        aiAssistantWindow.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.SMART_CHAT,
        );
      });
    } else {
      // Immediate mode set is better for performance
      aiAssistantWindow.webContents.send(
        'set-ui-mode',
        AIAssistantUIMode.SMART_CHAT,
      );
    }

    // Focus window to bring it to front
    aiAssistantWindow.focus();
  });

  // Register shortcut for Code Explainer (Ctrl+Cmd+E)
  globalShortcut.register('Command+Control+E', () => {
    // Simplified approach: directly read clipboard content
    const clipboardContent = clipboard.readText().trim();

    // Check if clipboard has content
    if (clipboardContent.length > 0) {
      // Check if code changed from last time
      const codeChanged = clipboardContent !== lastExplainedCode;

      // If window exists and is visible and code hasn't changed, hide it
      if (
        aiAssistantWindow &&
        !aiAssistantWindow.isDestroyed() &&
        aiAssistantWindow.isVisible() &&
        !codeChanged
      ) {
        aiAssistantWindow.hide();
        return;
      }

      // Store the current clipboard content for tracking changes
      lastExplainedCode = clipboardContent;

      // Create window if needed, otherwise use existing one
      if (!aiAssistantWindow || aiAssistantWindow.isDestroyed()) {
        aiAssistantWindow = createCodeaiAssistantWindow();
      }

      const processCode = () => {
        // Show the window if not visible
        if (!aiAssistantWindow.isVisible()) {
          showAIAssistantWindow();
        }

        // Send code to explain
        aiAssistantWindow.webContents.send('code-to-explain', clipboardContent);

        // Set UI mode based on clipboard content and last explanation state
        // If we had an explanation for this code previously and are reopening, try to restore it
        if (
          clipboardContent === lastExplainedCode &&
          lastExplanationCompleted &&
          lastUIMode === AIAssistantUIMode.INSIGHT_CHAT
        ) {
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            {
              code: clipboardContent,
              restoreExplanation: true,
            },
          );

          // Still request explanation in case we need to regenerate it
          // The renderer will handle showing the cached explanation if available
          anthropicService.explainCode(clipboardContent, aiAssistantWindow);
        } else {
          // Otherwise, use CHAT_WITH_EXPLANATION mode and request a new explanation
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            { code: clipboardContent },
          );

          // Request explanation
          anthropicService.explainCode(clipboardContent, aiAssistantWindow);

          // Reset explanation completed flag
          lastExplanationCompleted = false;
        }
      };

      // Handle window loading state
      if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
        aiAssistantWindow.webContents.once('did-finish-load', processCode);
      } else {
        processCode();
      }
    } else {
      // No content in clipboard - open pure chat interface

      // If window exists and is visible in PURE_CHAT mode, hide it
      // Since we can't directly know if it's in PURE_CHAT mode, we'll just hide it if empty clipboard
      if (
        aiAssistantWindow &&
        !aiAssistantWindow.isDestroyed() &&
        aiAssistantWindow.isVisible()
      ) {
        aiAssistantWindow.hide();
        return;
      }

      // Create or show explainer window
      if (!aiAssistantWindow || aiAssistantWindow.isDestroyed()) {
        aiAssistantWindow = createCodeaiAssistantWindow();
      }

      // Set UI mode to PURE_CHAT
      if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
        aiAssistantWindow.webContents.once('did-finish-load', () => {
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.SMART_CHAT,
          );
        });
      } else {
        aiAssistantWindow.webContents.send(
          'set-ui-mode',
          AIAssistantUIMode.SMART_CHAT,
        );
      }

      // Show the window
      showAIAssistantWindow();
    }

    // End of the new implementation
  });

  // The following is the old implementation, kept for reference
  /* 
  const getSelectedText = async () => {
      const path = require('path');
      const fs = require('fs');

      if (isDebug) {
        console.log(
          'Starting getSelectedText, saved original clipboard content',
        );
      }

      // Path to our compiled Swift tool
      const copyToolPath = path.join(app.getAppPath(), 'resources', 'CopyTool');

      // Make the tool executable if needed
      try {
        fs.chmodSync(copyToolPath, '755');
      } catch (err) {
        console.error('Error making CopyTool executable:', err);
      }

      return new Promise<string>((resolve) => {
        // Execute our Swift tool
        execFile(copyToolPath, (error, stdout, stderr) => {
          if (error) {
            console.error('Error executing CopyTool:', error);

            // Check if it's a permission issue
            if (stdout && stdout.includes('PERMISSION_NEEDED')) {
              console.log('Accessibility permission needed');

              // Show a dialog explaining the permission needed
              dialog
                .showMessageBox({
                  type: 'info',
                  title: 'Accessibility Permission Required',
                  message:
                    'SwitchV needs Accessibility permission to automatically copy selected text.',
                  detail:
                    'Please grant this permission in System Settings > Privacy & Security > Accessibility when prompted. After granting permission, try using the shortcut again.',
                  buttons: ['Cancel', 'Request Permission'],
                  defaultId: 1,
                })
                .then((result) => {
                  if (result.response === 1) {
                    // User wants to request permission, run tool with --prompt
                    execFile(copyToolPath, ['--prompt'], () => {
                      // Regardless of the outcome, resolve with the current clipboard content
                      resolve(clipboard.readText().trim());
                    });
                  } else {
                    // User canceled, resolve with current clipboard
                    resolve(clipboard.readText().trim());
                  }
                });
              return;
            }

            // For other errors, fall back to reading current clipboard
            resolve(clipboard.readText().trim());
            return;
          }

          // Check for special messages
          if (stdout && stdout.includes('NO_SELECTION')) {
            console.log('No text was selected');
            resolve('');
            return;
          }

          // Normal case - we got selected text
          const selectedText = stdout.trim();
          if (isDebug) {
            console.log('Selected text length:', selectedText.length);
          }

          resolve(selectedText);
        });
      });
    };

    // Get the selected text and continue with the explanation process
    getSelectedText().then((selectedCode) => {
      console.debug(
        'debug 1:' + selectedCode + ';' + lastExplainedCode,
        originalClipboard,
      );

      // export enum ExplainerUIMode {
      //   // Split view with code on top and explanation below
      //   SPLIT = 'split', // // original explainer mode1-1

      //   // Chat interface with code and explanation as first messages
      //   // The LLM has already been queried for an explanation
      //   CHAT_WITH_EXPLANATION = 'chat_with_explanation', // original explainer mode1-2 (default mode)

      //   TODO: add this case check
      //   // Chat interface with code as first message, but no explanation requested yet
      //   // User needs to ask a question first
      //   CHAT_WITH_CODE = 'chat_with_code', original explainer mode1-3 (new)

      //   // Pure chat interface with no code or explanation
      //   PURE_CHAT = 'pure_chat'
      // }

      // Check if this is different from previous code
      const codeChanged = selectedCode !== originalClipboard; // lastExplainedCode;

      if (isDebug) {
        console.log(
          'Code changed:',
          codeChanged,
          'Current length:',
          selectedCode.length,
        );
      }

      // 1. No text is selected (selectedCode.length === 0) OR
      // 2. Selected text is the same as last explained (codeChanged === false)
      if (!selectedCode?.length || !codeChanged) {
        if (isDebug) {
          console.log('No text selected, opening chat interface');
        }

        // If explainer window already exists and is visible, hide it
        if (
          aiAssistantWindow &&
          !aiAssistantWindow.isDestroyed() &&
          aiAssistantWindow.isVisible()
        ) {
          if (isDebug) {
            console.log(
              'Explainer window visible with no selection, hiding it',
            );
          }
          aiAssistantWindow.hide();
          return;
        }

        // Otherwise open explainer window with empty code - it will show pure chat interface
        aiAssistantWindow = createCodeaiAssistantWindow();

        if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
          console.log('aiAssistantWindow.webContents.isLoadingMainFrame()');
          aiAssistantWindow.webContents.once('did-finish-load', () => {
            aiAssistantWindow.webContents.send(
              'set-ui-mode',
              AIAssistantUIMode.SMART_CHAT,
            );
          });
        } else {
          // TODO: sometimes this would not show the new window 
          console.log(
            "aiAssistantWindow.webContents.send('set-ui-mode', AIAssistantUIMode.SMART_CHAT);",
          );
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.SMART_CHAT,
          );
        }
        showaiAssistantWindow();
        return;
      }

      // If text is selected but is the same as before
      if (!codeChanged) {
        if (isDebug) {
          console.log('Same text as before');
        }

        // If explainer window already exists and is visible, hide it
        // TODO: this has one edge case: if the opened window is the pure chat window, we should not hide it         
        if (
          aiAssistantWindow &&
          !aiAssistantWindow.isDestroyed() &&
          aiAssistantWindow.isVisible()
        ) {
          aiAssistantWindow.hide();
          return;
        }

        // If window exists but is hidden, show it with chat interface
        if (
          aiAssistantWindow &&
          !aiAssistantWindow.isDestroyed() &&
          !aiAssistantWindow.isVisible()
        ) {
          aiAssistantWindow.show();
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            { code: selectedCode },
          );
          return;
        }

        // Otherwise create new window with chat interface
        aiAssistantWindow = createCodeaiAssistantWindow();
        if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
          aiAssistantWindow.webContents.once('did-finish-load', () => {
            aiAssistantWindow.webContents.send('code-to-explain', selectedCode);
            aiAssistantWindow.webContents.send(
              'set-ui-mode',
              AIAssistantUIMode.INSIGHT_CHAT,
              { code: selectedCode },
            );
          });
        } else {
          console.log('aiAssistantWindow.webContents.code-to-explain()2');

          aiAssistantWindow.webContents.send('code-to-explain', selectedCode);
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            { code: selectedCode },
          );
        }
        showaiAssistantWindow();
        return;
      }

      // Update the tracked code
      lastExplainedCode = selectedCode;

      // Check if window already exists
      if (aiAssistantWindow && !aiAssistantWindow.isDestroyed()) {
        // If window is visible but code is same, toggle visibility (hide it)
        if (aiAssistantWindow.isVisible() && !codeChanged) {
          console.log('Hiding window, same code');
          aiAssistantWindow.hide();
          return;
        }

        // If window is visible and code changed, update with new code
        if (aiAssistantWindow.isVisible() && codeChanged) {
          console.log('Updating existing window with new code');

          // Send code and set UI mode to CHAT_WITH_EXPLANATION by default
          aiAssistantWindow.webContents.send('code-to-explain', selectedCode);
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            { code: selectedCode },
          );

          // Still explain code in the background so the explanation is available when toggled
          anthropicService.explainCode(selectedCode, aiAssistantWindow);
          return;
        }

        // If window exists but hidden, show it
        if (!aiAssistantWindow.isVisible()) {
          console.log('Showing existing window');
          aiAssistantWindow.show();

          // Send code and set UI mode to CHAT_WITH_EXPLANATION by default
          aiAssistantWindow.webContents.send('code-to-explain', selectedCode);
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            { code: selectedCode },
          );

          // Still explain code in the background so the explanation is available when toggled
          anthropicService.explainCode(selectedCode, aiAssistantWindow);
          return;
        }
      }

      // Create a new window if we didn't return yet
      console.log('Creating new explainer window');
      aiAssistantWindow = createCodeaiAssistantWindow();

      // Send the code once the window is ready
      const processCode = () => {
        if (!aiAssistantWindow.isVisible()) {
          // aiAssistantWindow.show();
          showaiAssistantWindow();
        }

        // Send code with a slight delay to ensure renderer is ready
        setTimeout(() => {
          // First send the code to the window
          aiAssistantWindow.webContents.send('code-to-explain', selectedCode);

          // Set UI mode to CHAT_WITH_EXPLANATION by default
          aiAssistantWindow.webContents.send(
            'set-ui-mode',
            AIAssistantUIMode.INSIGHT_CHAT,
            { code: selectedCode },
          );

          // Still explain code in the background so the explanation is available when toggled
          anthropicService.explainCode(selectedCode, aiAssistantWindow);
        }, 200);
      };

      // Handle window loading state
      if (aiAssistantWindow.webContents.isLoadingMainFrame()) {
        aiAssistantWindow.webContents.once('did-finish-load', processCode);
      } else {
        processCode();
      }
    });
  });  */
})();

// use lsof -i:55688 to check server process
// ref:
// 1. https://stackoverflow.com/questions/36031465/electron-kill-child-process-exec
// 2. https://stackoverflow.com/questions/42141191/electron-and-node-on-windows-kill-a-spawned-process
// Workaround to close all processes / sub-processes after closing the app
// app.once('window-all-closed', app.quit); ? seems not important
// mainWindow.removeAllListeners('close'); ? seems not important
app.once('before-quit', () => {
  if (serverProcess) {
    serverProcess.kill();
  }
});

app.setLoginItemSettings({
  openAtLogin: true,
});

app.dock.hide();
